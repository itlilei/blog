<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
=======
=======
    <title><![CDATA[git常用命令及问题汇总]]></title>
    <url>%2F2019%2F07%2F09%2FTools%2Fgit%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8F%8A%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"></content>
=======
=======
    <title><![CDATA[JS基础（二） toString、valueOf、Symbol.toPrimitive 类型转换]]></title>
    <url>%2F2019%2F07%2F10%2FFE%20%2FJS%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89%20toString%E3%80%81valueOf%E3%80%81Symbol.toPrimitive%20%2F</url>
    <content type="text"><![CDATA[概述javascript 中几乎所有类型都具有toString和valueOf属性，而且他们都有各自的toString或valueOf方法的实现，特殊情况下边讲到。 123Array.prototype.hasOwnProperty('valueOf'); //falseFunction.prototype.hasOwnProperty('valueOf'); //falseRegExp.prototype.hasOwnProperty('valueOf'); //false 只有Array,Function,RegExp的原型上没有valueOf属性,他们能有该方法是因为继承了Object，所以这三个对象调用的是Object原型上的valueOf。 特殊情况:null和undefined不能转换为字符串,null和undefined调用toString()方法会报错。转字符串的另一种方法：String(),他可以将null和undefined转换为字符串。 valueOf 介绍valueOf() 返回对象的原始值，如果对象没有原始值，valueOf() 就会返回对象自身。 对象 返回值 Array 返回数组对象本身 Boolean 布尔值 Date 返回时间的毫秒数 Function 函数本身 Number 数字的值 Object 对象本身 String 字符串的值 toString 介绍toString的作用是将值转换为字符串 对象 返回值 Array 将数组元素转换为字符串，用逗号拼接并返回(a=[1,2]=&gt; “1,2”) Boolean 返回’true’ ‘false’ Date 返回日期的字符串格式 “Wed Jul 10 2019 18:21:07 GMT+0800 (中国标准时间)” Function 函数本身的文本 “function a(){console.log(‘function’)}” Number 返回文本表示，可接收一个参数表示输出的进制数，默认为十进制 Object 返回 “[object 类型名]” String 字符串的值 valueOf toString 使用场景定义一个复杂对象，具体看下他们是如何执行的12345678910111213141516171819var test = &#123; i: 10, toString: function() &#123; console.log('toString'); return this.i; &#125;, valueOf: function() &#123; console.log('valueOf'); return this.i; &#125; &#125; alert(test);// 10 toString alert(+test); // 10 valueOf alert(''+test); // 10 valueOf alert(String(test)); // 10 toString alert(Number(test)); // 10 valueOf alert(test == '10'); // true valueOf alert(test === '10'); // false 结论 1. 在进行强转字符串类型时将优先调用toString方法，强转为数字时优先调用valueOf。 2. 在有运算操作符的情况下，valueOf的优先级高于toString。 3. 这两个方法一般是交由js去隐式调用，以满足不同的运算情况。 4. 在数值运算里，会优先调用valueOf()，如 a + b; 5. 在字符串运算里，会优先调用toString(),如alert(c). Symbol.toPrimitiveES6 的详细介绍： 对象的Symbol.toPrimitive属性，指向一个方法。该对象被转为原始类型的值时，会调用这个方法，返回该对象对应的原始类型值。 Symbol.toPrimitive被调用时，会接受一个字符串参数，表示当前运算的模式，一共有三种模式。 Number：该场合需要转成数值 String：该场合需要转成字符串 Default：该场合可以转成数值，也可以转成字符串12345678910111213141516171819let obj = &#123; [Symbol.toPrimitive](hint) &#123; switch (hint) &#123; case 'number': return 123; case 'string': return 'str'; case 'default': return 'default'; default: throw new Error(); &#125; &#125;&#125;;2 * obj // 2463 + obj // '3default'obj == 'default' // trueString(obj) // 'str' 可以通过一个例子看下三者的优先级12345678910111213let ab = &#123; valueOf() &#123; return 0; &#125;, toString() &#123; return '1'; &#125;, [Symbol.toPrimitive]() &#123; return 2; &#125;&#125;console.log(1+ab); //3console.log('1'+ab); //12 结论：在转换基本类型的时候，Symbol.toPrimitive 的优先级最高。 类型转换及原则双等号 == 的比较机制在判断的过程中会进行隐式的类型转换 1.是否有NaN 首先判断双等号两边是否有NaN，如果有的话，则一律返回false。 2.是否有boolean值 如果有的话则将true转化为1，false转化为0。 3.null和undefined 遇到null或者undefined，则不会进行类型转换，它们相互的比较都返回true。 4.有一边是字符串,分四种情况： 1） 同样是字符串，则直接进行字符串值的比较 2） 是数字，则需要将字符串转化为数字，然后进行比较 3） 有布尔类型，则要将布尔类型转化为0或则1，然后进行比较 4） 对象或者数组类型，则需要调用toString()或者valueOf()方法转化成简单类型，然后进行比较 对象转化为简单类型时会优先调用valueOf方法，如果可以与简单值进行比较则会直接比较，此时不再调用toString方法。如果调用valueOf方法后无法与简单值进行比较，则会再调用toString方法，最终得到比对的结果。但是需要注意的一点是Date对象不满足上述的规则，Date对象的toString和valueOf方法都是重新定义过的。默认会调用toString方法。 灵活运用：如何实现 (a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3) 的值为true分析：== 操作符在左右数据类型不一致时，会先进行隐式转换。a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3 的值意味着其不可能是基本数据类型。因此 a 是复杂数据类型，JS 中复杂数据类型只有 object，根据上边讲到的object转换类型的方法，得出答案。 Symbol.toPrimitive实现（其他两种亦可）：12345678910let a = &#123; [Symbol.toPrimitive]: (function(hint) &#123; let i = 1; //闭包的特性之一：i 不会被回收 return function() &#123; return i++; &#125; &#125;)()&#125;console.log(a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3); //true]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
>>>>>>> c483ddace7371600df7d8c2fc749cf6fa03eb8e8
    <title><![CDATA[解决hexo无法提交备份theme主题目录]]></title>
    <url>%2F2019%2F07%2F09%2FTools%2Fhexo%E4%B8%BB%E9%A2%98theme%E6%97%A0%E6%B3%95%E6%8F%90%E4%BA%A4%2F</url>
    <content type="text"><![CDATA[问题描述：提交代码到github后，在新的电脑clone项目时发现之前配置的样式丢失，然后才发现主题文件是空的。 解决办法：1git rm --cached themes/next #next为你的主题名 然后重新提交即可（ 如果还不行，看下改目录下是否有.git 隐藏文件夹，删除后 重新执行清除缓存操作。） 问题原因：因为我的项目是clone的官方项目，相当于一个子项目，这里用到了git 的子模块（git submodule）功能，子模块只是一个 HEAD 指针，指向子模块的 commit。相当于把一个大项目分成多个小项目，尽可能减少项目之间的关联，方便调试和修改。 关于子模块的详细描述，参考文档： https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E5%AD%90%E6%A8%A1%E5%9D%97]]></content>
>>>>>>> e197c5d8a43e7eb84fc49dd31c8606f21758b76f
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
<<<<<<< HEAD
>>>>>>> 2947c932778ea8ba876313138e47b44eeaae8392
    <title><![CDATA[解决hexo无法提交备份theme主题目录]]></title>
    <url>%2F2019%2F07%2F09%2FTools%2Fhexo%E4%B8%BB%E9%A2%98theme%E6%97%A0%E6%B3%95%E6%8F%90%E4%BA%A4%2F</url>
    <content type="text"><![CDATA[问题描述：提交代码到github后，在新的电脑clone项目时发现之前配置的样式丢失，然后才发现主题文件是空的。 解决办法：1git rm --cached themes/next #next为你的主题名 然后重新提交即可（ 如果还不行，看下改目录下是否有.git 隐藏文件夹，删除后 重新执行清除缓存操作。） 问题原因：因为我的项目是clone的官方项目，相当于一个子项目，这里用到了git 的子模块（git submodule）功能，子模块只是一个 HEAD 指针，指向子模块的 commit。相当于把一个大项目分成多个小项目，尽可能减少项目之间的关联，方便调试和修改。 关于子模块的详细描述，参考文档： https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E5%AD%90%E6%A8%A1%E5%9D%97]]></content>
=======
    <title><![CDATA[git常用命令及问题汇总]]></title>
    <url>%2F2019%2F07%2F09%2FTools%2Fgit%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8F%8A%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[Git配置ssh配置你的用户名和邮箱：12$ git config --global user.name "name"$ git config --global user.email "email@163.com" 生成ssh 1ssh-keygen -t rsa -C "your_email@youremail.com" Creates a new ssh key using the provided email # Generating public/private rsa # key pair.Enter file in which to save the key (/home/you/.ssh/id_rsa): 然后按两次Enter键 查看生成的公钥1cat ~/.ssh/id_rsa.pub 然后复制key到github或者gitlab 里 验证是否正常： 1ssh -T git@github.com]]></content>
>>>>>>> e197c5d8a43e7eb84fc49dd31c8606f21758b76f
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
>>>>>>> 7a77ce8429e2b835e4162736bfb92cc1fcbb61a6
    <title><![CDATA[JS基础（一）]]></title>
    <url>%2F2019%2F07%2F06%2FFE%20%2FJS%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
<<<<<<< HEAD
    <title><![CDATA[Promise对象]]></title>
=======
    <title><![CDATA[React-router4 分享 (一)]]></title>
>>>>>>> 7a77ce8429e2b835e4162736bfb92cc1fcbb61a6
    <url>%2F2019%2F07%2F05%2FFE%20%2FPromise%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
<<<<<<< HEAD
=======
        <tag>react</tag>
>>>>>>> 7a77ce8429e2b835e4162736bfb92cc1fcbb61a6
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fetch请求]]></title>
    <url>%2F2019%2F07%2F03%2FFE%20%2FFetch%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[基本的fetch请求1234567891011121314151617const options = &#123; method: "POST", // 请求参数 headers: &#123; "Content-Type": "application/json"&#125;, // 设置请求头 或者通过：new Headers(&#123;'Content-Type': 'application/json' &#125;) body: JSON.stringify(&#123;name:'123'&#125;), // 请求参数 credentials: "same-origin", // cookie设置 mode: "cors", // 跨域&#125;fetch('url'，options) .then(function(response) &#123; return response.json(); &#125;) .then(function(myJson) &#123; console.log(myJson); // 响应数据 &#125;).catch(function(err)&#123; console.log(err); // 异常处理 &#125;) fetch 请求返回promise对象 默认情况下，fetch 不会从服务端发送或接收任何 cookies，如果需发送cookie，必须设置 credentials 对象（下面会详细介绍） 涉及到的对象1. Request对象123456const myRequest = new Request('http://localhost/api', &#123;method: 'POST', body: '&#123;"foo":"bar"&#125;'&#125;); const myURL = myRequest.url; // http://localhost/apiconst myMethod = myRequest.method; // POSTconst myCred = myRequest.credentials; // omitconst bodyUsed = myRequest.bodyUsed; // true credentials有三个可选值（官方文档说现在的默认值修改为：same-origin）omit: 从不发送cookies.same-origin: 只有当URL与响应脚本同源才发送 cookies、 HTTP Basic authentication 等验证信息.(浏览器默认值,在旧版本浏览器，例如safari 11依旧是omit，safari 12已更改)include: 不论是不是跨域的请求,总是发送请求资源域在本地的 cookies、 HTTP Basic authentication 等验证信息]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VS Code 插件-图片自动上传工具 picgo]]></title>
    <url>%2F2019%2F07%2F03%2FTools%2F%E5%9B%BE%E7%89%87%E8%87%AA%E5%8A%A8%E4%B8%8A%E4%BC%A0%E5%B7%A5%E5%85%B7picgo%2F</url>
    <content type="text"><![CDATA[搜索 安装 picgo后 ，点击小齿轮配置github上传如下： 也可以再settings.json中配置： 1234"picgo.picBed.github.repo": "itlilei/name", // 仓库名，格式是username/reponame"picgo.picBed.github.token":"***", "picgo.picBed.github.branch": "master",// 分支名，默认是master"picgo.picBed.current": "github" 详细参数配置介绍可参考官方文档：https://picgo.github.io/PicGo-Doc/zh/guide/config.html#github%E5%9B%BE%E5%BA%8A 快捷键参考： 配置过程中遇到一个坑，github生成的token复制到onenote中，粘贴时默认首字母转换成大写了，导致一直上传失败，怀疑人生 /(ㄒoㄒ)/~~]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>VS Code</tag>
      </tags>
  </entry>
</search>
